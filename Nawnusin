import os
import json
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
)

BOT_TOKEN = os.getenv("BOT_TOKEN")
ADMIN_ID = None  # Put your Telegram user ID here
DATA_FILE = "students.json"

collecting = False
students = []
auto_stop_job = None

# Load saved students
if os.path.exists(DATA_FILE):
    with open(DATA_FILE, "r", encoding="utf-8") as f:
        students = json.load(f)

def save_data():
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(students, f, ensure_ascii=False)

# ğŸ”¥ AUTO STOP FUNCTION (runs after 30 minutes)
async def auto_stop(context: ContextTypes.DEFAULT_TYPE):
    global collecting
    collecting = False
    await context.bot.send_message(
        chat_id=context.job.chat_id,
        text="â° Ú©Ø§ØªÛŒ ØªÛ†Ù…Ø§Ø±Ú©Ø±Ø¯Ù† ØªÛ•ÙˆØ§Ùˆ Ø¨ÙˆÙˆ. Ù†Ø§ÙˆÛ•Ú©Ø§Ù† Ú•Ø§Ú¯ÛŒØ±Ø§."
    )

# /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("ğŸ¤– Ø³ÚµØ§Ùˆ! Ù…Ù† Ø¨Û†ØªÛŒ Ù†Ø§Ùˆ Ù†ÙˆÙˆØ³ÛŒÙ†Ù….")

# /startlesson
async def startlesson(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global collecting, students, auto_stop_job

    if ADMIN_ID and update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("âŒ ØªÛ•Ù†Ù‡Ø§ Ø¦Û•Ø¯Ù…ÛŒÙ† Ø¯Û•ØªÙˆØ§Ù†ÛØª.")
        return

    collecting = True
    students = []
    save_data()

    # Cancel previous timer if exists
    if auto_stop_job:
        auto_stop_job.schedule_removal()

    # Start 30 minute timer
    auto_stop_job = context.job_queue.run_once(
        auto_stop,
        when=1800,
        chat_id=update.effective_chat.id,
    )

    keyboard = [
        [InlineKeyboardButton("âœï¸ Ù†Ø§ÙˆÙ… ØªÛ†Ù…Ø§Ø±Ø¨Ú©Û•", callback_data="register")],
        [InlineKeyboardButton("ğŸ“‹ Ù¾ÛŒØ´Ø§Ù†Ø¯Ø§Ù†ÛŒ Ù„ÛŒØ³Øª", callback_data="list")],
        [InlineKeyboardButton("â›” ÙˆÛ•Ø³ØªØ§Ù†Ø¯Ù†", callback_data="stop")],
    ]

    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "ğŸ“š ÙˆØ§Ù†Û• Ø¯Û•Ø³ØªÛŒ Ù¾ÛÚ©Ø±Ø¯!\nØªÛ•Ù†Ù‡Ø§ 30 Ø®ÙˆÙ„Û•Ú© Ú©Ø§ØªØª Ù‡Û•ÛŒÛ• Ø¨Û† ØªÛ†Ù…Ø§Ø±Ú©Ø±Ø¯Ù†.",
        reply_markup=reply_markup,
    )

# Button handler
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global collecting, auto_stop_job

    query = update.callback_query
    await query.answer()

    if query.data == "register":
        if not collecting:
            await query.answer("âŒ Ù†Ø§ÙˆÛ•Ú©Ø§Ù† Ú•Ø§Ú¯ÛŒØ±Ø§.", show_alert=True)
            return

        name = query.from_user.first_name

        if name not in students:
            students.append(name)
            save_data()
            await query.answer("âœ… Ù†Ø§ÙˆÛ•Ú©Û•Øª ØªÛ†Ù…Ø§Ø±Ú©Ø±Ø§!", show_alert=True)
        else:
            await query.answer("âš ï¸ Ù¾ÛØ´ØªØ± ØªÛ†Ù…Ø§Ø±Ú©Ø±Ø§ÙˆÛŒØª.", show_alert=True)

    elif query.data == "list":
        if not students:
            await query.answer("âŒ Ù‡ÛŒÚ† Ù†Ø§ÙˆÛÚ© Ù†ÛŒÛŒÛ•.", show_alert=True)
        else:
            text = "ğŸ“‹ Ù„ÛŒØ³ØªÛŒ Ù‚ÙˆØªØ§Ø¨ÛŒØ§Ù†:\n"
            for i, name in enumerate(students, start=1):
                text += f"{i}. {name}\n"
            await query.message.reply_text(text)

    elif query.data == "stop":
        if ADMIN_ID and query.from_user.id != ADMIN_ID:
            await query.answer("âŒ ØªÛ•Ù†Ù‡Ø§ Ø¦Û•Ø¯Ù…ÛŒÙ†!", show_alert=True)
            return

        collecting = False

        # Cancel timer if admin stops manually
        if auto_stop_job:
            auto_stop_job.schedule_removal()

        await query.edit_message_text("â›” Ù†Ø§ÙˆÛ•Ú©Ø§Ù† Ú•Ø§Ú¯ÛŒØ±Ø§.")

# Build bot
app = ApplicationBuilder().token(BOT_TOKEN).build()

app.add_handler(CommandHandler("start", start))
app.add_handler(CommandHandler("startlesson", startlesson))
app.add_handler(CallbackQueryHandler(button_handler))

print("Ø¨Û†Øª Ú©Ø§Ø±Ø¯Û•Ú©Ø§Øª...")
app.run_polling()
